struct VS_Out {
  float4 position	: POSITION;
  float3 color		: COLOR;
  float2 texCoord	: TEXCOORD0;
  float3 normal		: TEXCOORD1;
  float3 lightDir	: TEXCOORD2;
  float3 eyeDir		: TEXCOORD3;
};

VS_Out vertexPixelLight(float3 position : POSITION,
						float3 normal   : NORMAL,
						float3 color    : COLOR,
						float2 texCoord : TEXCOORD0,

						uniform float4x4 modelViewProj,
						uniform float4x4 inverseModelToWorld,
						uniform float3 lightPosition,
						uniform float3 cameraPosition)
{
	VS_Out OUT;

	//instead of using inverseModelToWorld matrix on light and camera position, we can use ModelToWorld matrix on vertex
	//and perform calculations on world space rather than object space

	lightPosition = mul(inverseModelToWorld, float4(lightPosition, 1)).xyz;
	lightPosition = normalize(lightPosition - position);

	cameraPosition = mul(inverseModelToWorld, float4(lightPos, 1)).xyz;
	cameraPosition = normalize(cameraPosition - position);

	float4 vertexPosition = float4(position, 1);
	vertexPosition = mul(modelViewProj, position);

	OUT.position	= vertexPosition;
	OUT.color		= color;
	OUT.texCoord	= texCoord;
	OUT.normal		= normalize(normal);	//just in case
	OUT.lightDir	= lightPosition;
	OUT.eyeDir		= cameraPosition;

	return OUT;	
}